name: Preview Screenshots

on:
  workflow_run:
    workflows: ["Preview Deployment"]
    types:
      - completed

jobs:
  screenshots:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'pull_request' }}
    name: Capture Screenshots
    permissions:
      contents: write
      pull-requests: write
      actions: read

    steps:
      - uses: actions/checkout@v4

      - name: Get PR number from workflow run
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            // Try to get PR number from workflow_run payload
            const prNumber = context.payload.workflow_run.pull_requests[0]?.number;

            if (prNumber) {
              core.setOutput('number', prNumber);
              core.setOutput('found', 'true');
              console.log(`Found PR #${prNumber} from workflow_run payload`);
              return;
            }

            // Fallback: search for PR by head SHA (works for fork PRs too)
            const headSha = context.payload.workflow_run.head_sha;
            console.log(`Searching for PR with head SHA: ${headSha}`);

            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            const matchingPr = prs.find(pr => pr.head.sha === headSha);

            if (matchingPr) {
              core.setOutput('number', matchingPr.number);
              core.setOutput('found', 'true');
              console.log(`Found PR #${matchingPr.number} by SHA match`);
              return;
            }

            // Final fallback: search by branch name (same-repo PRs only)
            const headBranch = context.payload.workflow_run.head_branch;
            console.log(`Searching for PR with head branch: ${headBranch}`);

            const branchPr = prs.find(pr =>
              pr.head.ref === headBranch &&
              pr.head.repo?.full_name === `${context.repo.owner}/${context.repo.repo}`
            );

            if (branchPr) {
              core.setOutput('number', branchPr.number);
              core.setOutput('found', 'true');
              console.log(`Found PR #${branchPr.number} by branch match`);
              return;
            }

            core.setOutput('found', 'false');
            core.setFailed(`Could not find PR for SHA ${headSha} or branch ${headBranch}`);

      - name: Build preview URL
        if: steps.pr.outputs.found == 'true'
        id: preview
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          # Cloudflare Workers subdomain - update if account changes
          WORKERS_SUBDOMAIN: palladio-registry.workers.dev
        run: |
          PREVIEW_URL="https://breathe-together-v2-pr-${PR_NUMBER}.${WORKERS_SUBDOMAIN}"
          echo "url=${PREVIEW_URL}" >> $GITHUB_OUTPUT
          echo "Preview URL: ${PREVIEW_URL}"

      - name: Wait for preview to be ready
        if: steps.pr.outputs.found == 'true'
        run: |
          echo "Waiting for preview deployment to be accessible..."
          PREVIEW_URL="${{ steps.preview.outputs.url }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PREVIEW_URL" || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Preview is ready (HTTP $HTTP_STATUS)"
              exit 0
            fi
            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS: HTTP $HTTP_STATUS, waiting..."
            sleep 5
            ATTEMPT=$((ATTEMPT + 1))
          done

          echo "::warning::Preview may not be fully ready after ${MAX_ATTEMPTS} attempts, proceeding anyway..."

      - name: Setup Node.js
        if: steps.pr.outputs.found == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        if: steps.pr.outputs.found == 'true'
        run: |
          npm init -y
          npm install playwright@latest
          npx playwright install chromium --with-deps

      - name: Create screenshot script
        if: steps.pr.outputs.found == 'true'
        run: |
          cat > screenshot.mjs << 'EOF'
          import { chromium } from 'playwright';
          import { mkdir } from 'fs/promises';
          import { existsSync } from 'fs';

          const PREVIEW_URL = process.env.PREVIEW_URL;
          const SCREENSHOTS_DIR = './screenshots';

          // Viewport configurations
          const viewports = [
            { name: 'desktop', width: 1920, height: 1080 },
            { name: 'tablet', width: 768, height: 1024 },
            { name: 'mobile', width: 375, height: 667 },
          ];

          async function captureScreenshots() {
            if (!existsSync(SCREENSHOTS_DIR)) {
              await mkdir(SCREENSHOTS_DIR, { recursive: true });
            }

            let browser;
            try {
              browser = await chromium.launch({
                args: ['--use-gl=angle', '--use-angle=swiftshader'],
              });

              console.log(`Capturing screenshots from: ${PREVIEW_URL}`);

              for (const viewport of viewports) {
                console.log(`\nCapturing ${viewport.name} (${viewport.width}x${viewport.height})...`);

                const context = await browser.newContext({
                  viewport: { width: viewport.width, height: viewport.height },
                  // Use 1x scale to keep file sizes reasonable
                  deviceScaleFactor: 1,
                });

                const page = await context.newPage();

                try {
                  // Navigate to the preview URL
                  await page.goto(PREVIEW_URL, {
                    waitUntil: 'networkidle',
                    timeout: 60000,
                  });

                  // Wait for WebGL canvas to render
                  await page.waitForSelector('canvas', { timeout: 30000 });

                  // Additional wait for Three.js scene to initialize and render
                  await page.waitForTimeout(5000);

                  // Capture initial state
                  await page.screenshot({
                    path: `${SCREENSHOTS_DIR}/${viewport.name}-initial.png`,
                    fullPage: false,
                  });
                  console.log(`  ‚úì Captured ${viewport.name}-initial.png`);

                  // Wait a few seconds for breathing animation to progress
                  await page.waitForTimeout(4000);

                  // Capture mid-cycle state
                  await page.screenshot({
                    path: `${SCREENSHOTS_DIR}/${viewport.name}-animation.png`,
                    fullPage: false,
                  });
                  console.log(`  ‚úì Captured ${viewport.name}-animation.png`);

                } catch (error) {
                  console.error(`  ‚úó Error capturing ${viewport.name}:`, error.message);

                  // Try to capture whatever is on screen for debugging
                  try {
                    await page.screenshot({
                      path: `${SCREENSHOTS_DIR}/${viewport.name}-error.png`,
                      fullPage: false,
                    });
                    console.log(`  ‚úì Captured ${viewport.name}-error.png (fallback)`);
                  } catch (e) {
                    console.error(`  ‚úó Could not capture fallback screenshot`);
                  }
                } finally {
                  await context.close();
                }
              }

              console.log('\nScreenshot capture complete!');
            } finally {
              if (browser) {
                await browser.close();
              }
            }
          }

          captureScreenshots().catch((error) => {
            console.error('Fatal error:', error);
            process.exit(1);
          });
          EOF

      - name: Capture screenshots
        id: capture
        if: steps.pr.outputs.found == 'true'
        continue-on-error: true
        env:
          PREVIEW_URL: ${{ steps.preview.outputs.url }}
        run: |
          node screenshot.mjs
          # Check if we got any screenshots
          if [ -d "./screenshots" ] && [ "$(ls -A ./screenshots 2>/dev/null)" ]; then
            echo "has_screenshots=true" >> $GITHUB_OUTPUT
            echo "Screenshots captured:"
            ls -la ./screenshots/
          else
            echo "has_screenshots=false" >> $GITHUB_OUTPUT
            echo "::warning::No screenshots were captured"
          fi

      - name: Upload screenshots as artifact
        if: steps.pr.outputs.found == 'true' && steps.capture.outputs.has_screenshots == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: preview-screenshots-pr-${{ steps.pr.outputs.number }}
          path: screenshots/
          retention-days: 30
          if-no-files-found: warn

      - name: Push screenshots to branch for inline display
        if: steps.pr.outputs.found == 'true' && steps.capture.outputs.has_screenshots == 'true'
        id: push_screenshots
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Save screenshots to temp location before branch switch
          TEMP_SCREENSHOTS="/tmp/screenshots-pr-${PR_NUMBER}"
          mkdir -p "${TEMP_SCREENSHOTS}"
          cp ./screenshots/*.png "${TEMP_SCREENSHOTS}/"
          echo "Saved screenshots to temp location:"
          ls -la "${TEMP_SCREENSHOTS}/"

          # Also save the file list for later use (since we switch branches)
          ls ./screenshots/*.png | xargs -n1 basename > "${TEMP_SCREENSHOTS}/filelist.txt"
          echo "Screenshot files:"
          cat "${TEMP_SCREENSHOTS}/filelist.txt"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create or checkout the screenshots branch
          SCREENSHOTS_BRANCH="screenshots"
          PR_FOLDER="pr-${PR_NUMBER}"

          # Fetch the branch if it exists, or create it as orphan
          if git ls-remote --heads origin ${SCREENSHOTS_BRANCH} | grep -q ${SCREENSHOTS_BRANCH}; then
            git fetch origin ${SCREENSHOTS_BRANCH}:${SCREENSHOTS_BRANCH}
            git checkout ${SCREENSHOTS_BRANCH}
            # Pull latest to avoid push conflicts from concurrent runs
            git pull origin ${SCREENSHOTS_BRANCH} --rebase || true
          else
            git checkout --orphan ${SCREENSHOTS_BRANCH}
            git rm -rf . 2>/dev/null || true
            echo "# Preview Screenshots" > README.md
            echo "" >> README.md
            echo "This branch contains automatically generated screenshots from PR previews." >> README.md
            git add README.md
            git commit -m "Initialize screenshots branch"
          fi

          # Clean up old screenshots for this PR and add new ones from temp location
          rm -rf "${PR_FOLDER}"
          mkdir -p "${PR_FOLDER}"
          cp "${TEMP_SCREENSHOTS}"/*.png "${PR_FOLDER}/"
          echo "Copied screenshots to PR folder:"
          ls -la "${PR_FOLDER}/"

          # Commit and push with retry logic for concurrent workflows
          git add "${PR_FOLDER}"
          git commit -m "Update screenshots for PR #${PR_NUMBER}" || echo "No changes to commit"

          # Retry push up to 3 times to handle race conditions
          PUSH_ATTEMPTS=0
          MAX_PUSH_ATTEMPTS=3
          while [ $PUSH_ATTEMPTS -lt $MAX_PUSH_ATTEMPTS ]; do
            if git push origin ${SCREENSHOTS_BRANCH}; then
              echo "Push succeeded on attempt $((PUSH_ATTEMPTS + 1))"
              break
            else
              PUSH_ATTEMPTS=$((PUSH_ATTEMPTS + 1))
              if [ $PUSH_ATTEMPTS -lt $MAX_PUSH_ATTEMPTS ]; then
                echo "Push failed, retrying after pull... (attempt $PUSH_ATTEMPTS of $MAX_PUSH_ATTEMPTS)"
                git pull origin ${SCREENSHOTS_BRANCH} --rebase || true
                sleep 2
              else
                echo "::warning::Push failed after $MAX_PUSH_ATTEMPTS attempts, using force push"
                git push --force-with-lease origin ${SCREENSHOTS_BRANCH}
              fi
            fi
          done

          # Get the commit SHA for cache-busting in image URLs
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "Pushed commit: ${COMMIT_SHA}"

          # Small delay to allow GitHub CDN to update
          sleep 3

          # Cleanup temp (but keep filelist for comment step)
          cp "${TEMP_SCREENSHOTS}/filelist.txt" /tmp/screenshot-filelist.txt
          rm -rf "${TEMP_SCREENSHOTS}"

          # Output values for comment step
          echo "branch=${SCREENSHOTS_BRANCH}" >> $GITHUB_OUTPUT
          echo "folder=${PR_FOLDER}" >> $GITHUB_OUTPUT
          echo "commit_sha=${COMMIT_SHA}" >> $GITHUB_OUTPUT
          echo "push_success=true" >> $GITHUB_OUTPUT

      - name: Comment PR with screenshots
        if: steps.pr.outputs.found == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          PREVIEW_URL: ${{ steps.preview.outputs.url }}
          WORKFLOW_RUN_ID: ${{ github.run_id }}
          HAS_SCREENSHOTS: ${{ steps.capture.outputs.has_screenshots }}
          CAPTURE_OUTCOME: ${{ steps.capture.outcome }}
          SCREENSHOTS_BRANCH: ${{ steps.push_screenshots.outputs.branch }}
          SCREENSHOTS_FOLDER: ${{ steps.push_screenshots.outputs.folder }}
          SCREENSHOTS_COMMIT_SHA: ${{ steps.push_screenshots.outputs.commit_sha }}
          PUSH_SUCCESS: ${{ steps.push_screenshots.outputs.push_success }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = parseInt(process.env.PR_NUMBER);
            const previewUrl = process.env.PREVIEW_URL;
            const workflowRunId = process.env.WORKFLOW_RUN_ID;
            const hasScreenshots = process.env.HAS_SCREENSHOTS === 'true';
            const captureOutcome = process.env.CAPTURE_OUTCOME;
            const screenshotsBranch = process.env.SCREENSHOTS_BRANCH || 'screenshots';
            const screenshotsFolder = process.env.SCREENSHOTS_FOLDER || `pr-${prNumber}`;
            const commitSha = process.env.SCREENSHOTS_COMMIT_SHA;
            const pushSuccess = process.env.PUSH_SUCCESS === 'true';
            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
            const artifactUrl = `${repoUrl}/actions/runs/${workflowRunId}`;
            const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19) + ' UTC';

            // Use commit SHA in URLs to avoid CDN caching issues
            // Fall back to branch name if SHA not available
            const refForUrl = commitSha || screenshotsBranch;
            const rawBaseUrl = `https://raw.githubusercontent.com/${context.repo.owner}/${context.repo.repo}/${refForUrl}/${screenshotsFolder}`;

            console.log(`Using image base URL: ${rawBaseUrl}`);
            console.log(`Push success: ${pushSuccess}, Commit SHA: ${commitSha}`);

            // Read screenshot file list from temp file (saved before branch switch)
            let screenshotFiles = [];
            try {
              const filelistPath = '/tmp/screenshot-filelist.txt';
              if (fs.existsSync(filelistPath)) {
                const content = fs.readFileSync(filelistPath, 'utf8');
                screenshotFiles = content.trim().split('\n').filter(f => f.endsWith('.png'));
                console.log(`Found ${screenshotFiles.length} screenshots from filelist: ${screenshotFiles.join(', ')}`);
              } else {
                console.log('Filelist not found at /tmp/screenshot-filelist.txt');
              }
            } catch (e) {
              console.log('Error reading filelist:', e.message);
            }

            // Fallback: try to read from current directory (may work in some cases)
            if (screenshotFiles.length === 0) {
              console.log('Trying fallback directories...');
              const fallbackDirs = [`./${screenshotsFolder}`, './screenshots'];
              for (const dir of fallbackDirs) {
                try {
                  screenshotFiles = fs.readdirSync(dir).filter(f => f.endsWith('.png'));
                  if (screenshotFiles.length > 0) {
                    console.log(`Found ${screenshotFiles.length} screenshots in ${dir}`);
                    break;
                  }
                } catch (e) {
                  console.log(`Directory ${dir} not accessible`);
                }
              }
            }

            // If still no files found but we know screenshots were captured, use expected filenames
            if (screenshotFiles.length === 0 && hasScreenshots) {
              console.log('Using expected screenshot filenames as fallback');
              screenshotFiles = [
                'desktop-initial.png', 'desktop-animation.png',
                'tablet-initial.png', 'tablet-animation.png',
                'mobile-initial.png', 'mobile-animation.png'
              ];
            }

            // Build status indicator
            let statusEmoji, statusText;
            if (hasScreenshots && captureOutcome === 'success' && pushSuccess) {
              statusEmoji = '‚úÖ';
              statusText = 'Screenshots captured and uploaded successfully';
            } else if (hasScreenshots && captureOutcome === 'success' && !pushSuccess) {
              statusEmoji = '‚ö†Ô∏è';
              statusText = 'Screenshots captured but push may have failed - images might not display';
            } else if (hasScreenshots) {
              statusEmoji = '‚ö†Ô∏è';
              statusText = 'Partial capture (some viewports may have failed)';
            } else {
              statusEmoji = '‚ùå';
              statusText = 'Screenshot capture failed - check workflow logs';
            }

            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.data.find(comment =>
              comment.body.includes('<!-- preview-screenshots-comment -->')
            );

            const bodyParts = [
              '<!-- preview-screenshots-comment -->',
              '## üì∏ Preview Screenshots',
              '',
              `${statusEmoji} ${statusText}`,
              '',
              `Screenshots captured from [preview deployment](${previewUrl})`,
              '',
            ];

            if (hasScreenshots) {
              // Group screenshots by device
              const devices = [
                { name: 'Desktop', prefix: 'desktop', emoji: 'üñ•Ô∏è', resolution: '1920√ó1080' },
                { name: 'Tablet', prefix: 'tablet', emoji: 'üì±', resolution: '768√ó1024' },
                { name: 'Mobile', prefix: 'mobile', emoji: 'üì±', resolution: '375√ó667' },
              ];

              for (const device of devices) {
                const deviceFiles = screenshotFiles.filter(f => f.startsWith(device.prefix));
                if (deviceFiles.length > 0) {
                  bodyParts.push(
                    `### ${device.emoji} ${device.name} (${device.resolution})`,
                    '',
                  );

                  // Add images in a table for side-by-side comparison
                  const initialFile = deviceFiles.find(f => f.includes('initial'));
                  const animationFile = deviceFiles.find(f => f.includes('animation'));
                  const errorFile = deviceFiles.find(f => f.includes('error'));

                  if (initialFile && animationFile) {
                    bodyParts.push(
                      '| Initial State | Animation State |',
                      '|:-------------:|:---------------:|',
                      `| ![Initial](${rawBaseUrl}/${initialFile}) | ![Animation](${rawBaseUrl}/${animationFile}) |`,
                      '',
                    );
                  } else if (initialFile) {
                    bodyParts.push(
                      `![${device.name} Initial](${rawBaseUrl}/${initialFile})`,
                      '',
                    );
                  } else if (errorFile) {
                    bodyParts.push(
                      `![${device.name} Error State](${rawBaseUrl}/${errorFile})`,
                      '',
                      '> ‚ö†Ô∏è Error occurred during capture - showing fallback screenshot',
                      '',
                    );
                  }
                }
              }

              bodyParts.push(
                '<details>',
                '<summary>üì• Download Options</summary>',
                '',
                `- [Download as Artifact](${artifactUrl}) (zip with all screenshots)`,
                `- [Browse on GitHub](${repoUrl}/tree/${screenshotsBranch}/${screenshotsFolder})`,
                '',
                '</details>',
              );
            }

            bodyParts.push(
              '',
              '---',
              `<sub>Last run: ${timestamp} ‚Ä¢ [View Workflow Run](${artifactUrl})</sub>`,
            );

            const body = bodyParts.join('\n');

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body,
              });
              console.log('Updated existing screenshot comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body,
              });
              console.log('Created new screenshot comment');
            }
