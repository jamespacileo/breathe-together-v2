name: Preview Screenshots

on:
  workflow_run:
    workflows: ["Preview Deployment"]
    types:
      - completed

jobs:
  screenshots:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'pull_request' }}
    name: Capture Screenshots
    permissions:
      contents: write
      pull-requests: write
      actions: read

    steps:
      - uses: actions/checkout@v4

      - name: Get PR number from workflow run
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            // Try to get PR number from workflow_run payload
            const prNumber = context.payload.workflow_run.pull_requests[0]?.number;

            if (prNumber) {
              core.setOutput('number', prNumber);
              core.setOutput('found', 'true');
              console.log(`Found PR #${prNumber} from workflow_run payload`);
              return;
            }

            // Fallback: search for PR by head SHA (works for fork PRs too)
            const headSha = context.payload.workflow_run.head_sha;
            console.log(`Searching for PR with head SHA: ${headSha}`);

            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            const matchingPr = prs.find(pr => pr.head.sha === headSha);

            if (matchingPr) {
              core.setOutput('number', matchingPr.number);
              core.setOutput('found', 'true');
              console.log(`Found PR #${matchingPr.number} by SHA match`);
              return;
            }

            // Final fallback: search by branch name (same-repo PRs only)
            const headBranch = context.payload.workflow_run.head_branch;
            console.log(`Searching for PR with head branch: ${headBranch}`);

            const branchPr = prs.find(pr =>
              pr.head.ref === headBranch &&
              pr.head.repo?.full_name === `${context.repo.owner}/${context.repo.repo}`
            );

            if (branchPr) {
              core.setOutput('number', branchPr.number);
              core.setOutput('found', 'true');
              console.log(`Found PR #${branchPr.number} by branch match`);
              return;
            }

            core.setOutput('found', 'false');
            core.setFailed(`Could not find PR for SHA ${headSha} or branch ${headBranch}`);

      - name: Build preview URL
        if: steps.pr.outputs.found == 'true'
        id: preview
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          # Cloudflare Workers subdomain - update if account changes
          WORKERS_SUBDOMAIN: palladio-registry.workers.dev
        run: |
          PREVIEW_URL="https://breathe-together-v2-pr-${PR_NUMBER}.${WORKERS_SUBDOMAIN}"
          echo "url=${PREVIEW_URL}" >> $GITHUB_OUTPUT
          echo "Preview URL: ${PREVIEW_URL}"

      - name: Wait for preview to be ready
        if: steps.pr.outputs.found == 'true'
        run: |
          echo "Waiting for preview deployment to be accessible..."
          PREVIEW_URL="${{ steps.preview.outputs.url }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PREVIEW_URL" || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Preview is ready (HTTP $HTTP_STATUS)"
              exit 0
            fi
            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS: HTTP $HTTP_STATUS, waiting..."
            sleep 5
            ATTEMPT=$((ATTEMPT + 1))
          done

          echo "::warning::Preview may not be fully ready after ${MAX_ATTEMPTS} attempts, proceeding anyway..."

      - name: Setup Node.js
        if: steps.pr.outputs.found == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        if: steps.pr.outputs.found == 'true'
        run: |
          npm init -y
          npm install playwright@latest
          npx playwright install chromium --with-deps

      - name: Create screenshot script
        if: steps.pr.outputs.found == 'true'
        run: |
          cat > screenshot.mjs << 'EOF'
          import { chromium } from 'playwright';
          import { mkdir, readFile } from 'fs/promises';
          import { existsSync } from 'fs';

          const PREVIEW_URL = process.env.PREVIEW_URL;
          const UPLOAD_URL = process.env.UPLOAD_URL;
          const API_KEY = process.env.API_KEY || '';
          const PR_NUMBER = process.env.PR_NUMBER;
          const SCREENSHOTS_DIR = './screenshots';

          // Viewport configurations
          const viewports = [
            { name: 'desktop', width: 1920, height: 1080 },
            { name: 'tablet', width: 768, height: 1024 },
            { name: 'mobile', width: 375, height: 667 },
          ];

          /**
           * Upload a screenshot to R2 via the API
           */
          async function uploadToR2(filepath, viewport, state) {
            if (!UPLOAD_URL) {
              console.log(`  ‚è≠Ô∏è  Skipping R2 upload (no UPLOAD_URL configured)`);
              return null;
            }

            try {
              const imageData = await readFile(filepath);
              const formData = new FormData();
              formData.append('file', new Blob([imageData], { type: 'image/png' }), `${viewport}-${state}.png`);
              formData.append('prNumber', PR_NUMBER);
              formData.append('viewport', viewport);
              formData.append('state', state);

              const response = await fetch(`${UPLOAD_URL}/api/screenshots`, {
                method: 'POST',
                body: formData,
                headers: API_KEY ? { 'X-API-Key': API_KEY } : {},
              });

              if (!response.ok) {
                const error = await response.text();
                throw new Error(`Upload failed: ${response.status} ${error}`);
              }

              const result = await response.json();
              console.log(`  ‚òÅÔ∏è  Uploaded to R2: ${result.url}`);
              return result;
            } catch (error) {
              console.error(`  ‚ö†Ô∏è  R2 upload failed:`, error.message);
              return null;
            }
          }

          async function captureScreenshots() {
            if (!existsSync(SCREENSHOTS_DIR)) {
              await mkdir(SCREENSHOTS_DIR, { recursive: true });
            }

            const uploadResults = [];
            let browser;
            try {
              browser = await chromium.launch({
                args: ['--use-gl=angle', '--use-angle=swiftshader'],
              });

              console.log(`Capturing screenshots from: ${PREVIEW_URL}`);
              if (UPLOAD_URL) {
                console.log(`Uploading to R2 at: ${UPLOAD_URL}`);
              }

              for (const viewport of viewports) {
                console.log(`\nCapturing ${viewport.name} (${viewport.width}x${viewport.height})...`);

                const context = await browser.newContext({
                  viewport: { width: viewport.width, height: viewport.height },
                  // Use 1x scale to keep file sizes reasonable
                  deviceScaleFactor: 1,
                });

                const page = await context.newPage();

                try {
                  // Navigate to the preview URL
                  await page.goto(PREVIEW_URL, {
                    waitUntil: 'networkidle',
                    timeout: 60000,
                  });

                  // Wait for WebGL canvas to render
                  await page.waitForSelector('canvas', { timeout: 30000 });

                  // Additional wait for Three.js scene to initialize and render
                  await page.waitForTimeout(5000);

                  // Capture initial state
                  const initialPath = `${SCREENSHOTS_DIR}/${viewport.name}-initial.png`;
                  await page.screenshot({
                    path: initialPath,
                    fullPage: false,
                  });
                  console.log(`  ‚úì Captured ${viewport.name}-initial.png`);

                  // Upload to R2
                  const initialUpload = await uploadToR2(initialPath, viewport.name, 'initial');
                  if (initialUpload) uploadResults.push(initialUpload);

                  // Wait a few seconds for breathing animation to progress
                  await page.waitForTimeout(4000);

                  // Capture mid-cycle state
                  const animationPath = `${SCREENSHOTS_DIR}/${viewport.name}-animation.png`;
                  await page.screenshot({
                    path: animationPath,
                    fullPage: false,
                  });
                  console.log(`  ‚úì Captured ${viewport.name}-animation.png`);

                  // Upload to R2
                  const animationUpload = await uploadToR2(animationPath, viewport.name, 'animation');
                  if (animationUpload) uploadResults.push(animationUpload);

                } catch (error) {
                  console.error(`  ‚úó Error capturing ${viewport.name}:`, error.message);

                  // Try to capture whatever is on screen for debugging
                  try {
                    const errorPath = `${SCREENSHOTS_DIR}/${viewport.name}-error.png`;
                    await page.screenshot({
                      path: errorPath,
                      fullPage: false,
                    });
                    console.log(`  ‚úì Captured ${viewport.name}-error.png (fallback)`);

                    // Upload error screenshot to R2
                    const errorUpload = await uploadToR2(errorPath, viewport.name, 'error');
                    if (errorUpload) uploadResults.push(errorUpload);
                  } catch (e) {
                    console.error(`  ‚úó Could not capture fallback screenshot`);
                  }
                } finally {
                  await context.close();
                }
              }

              console.log('\nScreenshot capture complete!');
              if (uploadResults.length > 0) {
                console.log(`\nUploaded ${uploadResults.length} screenshots to R2:`);
                for (const result of uploadResults) {
                  console.log(`  - ${result.key}`);
                }
              }
            } finally {
              if (browser) {
                await browser.close();
              }
            }
          }

          captureScreenshots().catch((error) => {
            console.error('Fatal error:', error);
            process.exit(1);
          });
          EOF

      - name: Capture screenshots
        id: capture
        if: steps.pr.outputs.found == 'true'
        continue-on-error: true
        env:
          PREVIEW_URL: ${{ steps.preview.outputs.url }}
          UPLOAD_URL: https://breathe-together-v2.palladio-registry.workers.dev
          API_KEY: ${{ secrets.SCREENSHOTS_API_KEY }}
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        run: |
          node screenshot.mjs
          # Check if we got any screenshots
          if [ -d "./screenshots" ] && [ "$(ls -A ./screenshots 2>/dev/null)" ]; then
            echo "has_screenshots=true" >> $GITHUB_OUTPUT
            echo "Screenshots captured:"
            ls -la ./screenshots/
          else
            echo "has_screenshots=false" >> $GITHUB_OUTPUT
            echo "::warning::No screenshots were captured"
          fi

      - name: Upload screenshots as artifact
        if: steps.pr.outputs.found == 'true' && steps.capture.outputs.has_screenshots == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: preview-screenshots-pr-${{ steps.pr.outputs.number }}
          path: screenshots/
          retention-days: 30
          if-no-files-found: warn

      - name: Push screenshots to branch for inline display
        if: steps.pr.outputs.found == 'true' && steps.capture.outputs.has_screenshots == 'true'
        id: push_screenshots
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Save screenshots to temp location before branch switch
          TEMP_SCREENSHOTS="/tmp/screenshots-pr-${PR_NUMBER}"
          mkdir -p "${TEMP_SCREENSHOTS}"
          cp ./screenshots/*.png "${TEMP_SCREENSHOTS}/"
          echo "Saved screenshots to temp location:"
          ls -la "${TEMP_SCREENSHOTS}/"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create or checkout the screenshots branch
          SCREENSHOTS_BRANCH="screenshots"
          PR_FOLDER="pr-${PR_NUMBER}"

          # Fetch the branch if it exists, or create it as orphan
          if git ls-remote --heads origin ${SCREENSHOTS_BRANCH} | grep -q ${SCREENSHOTS_BRANCH}; then
            git fetch origin ${SCREENSHOTS_BRANCH}
            git checkout ${SCREENSHOTS_BRANCH}
          else
            git checkout --orphan ${SCREENSHOTS_BRANCH}
            git rm -rf . 2>/dev/null || true
            echo "# Preview Screenshots" > README.md
            echo "" >> README.md
            echo "This branch contains automatically generated screenshots from PR previews." >> README.md
            git add README.md
            git commit -m "Initialize screenshots branch"
          fi

          # Clean up old screenshots for this PR and add new ones from temp location
          rm -rf "${PR_FOLDER}"
          mkdir -p "${PR_FOLDER}"
          cp "${TEMP_SCREENSHOTS}"/*.png "${PR_FOLDER}/"
          echo "Copied screenshots to PR folder:"
          ls -la "${PR_FOLDER}/"

          # Commit and push
          git add "${PR_FOLDER}"
          git commit -m "Update screenshots for PR #${PR_NUMBER}" || echo "No changes to commit"
          git push origin ${SCREENSHOTS_BRANCH}

          # Cleanup temp
          rm -rf "${TEMP_SCREENSHOTS}"

          # Output the raw URL base
          echo "branch=${SCREENSHOTS_BRANCH}" >> $GITHUB_OUTPUT
          echo "folder=${PR_FOLDER}" >> $GITHUB_OUTPUT

      - name: Comment PR with screenshots
        if: steps.pr.outputs.found == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          PREVIEW_URL: ${{ steps.preview.outputs.url }}
          WORKFLOW_RUN_ID: ${{ github.run_id }}
          HAS_SCREENSHOTS: ${{ steps.capture.outputs.has_screenshots }}
          CAPTURE_OUTCOME: ${{ steps.capture.outcome }}
          SCREENSHOTS_BRANCH: ${{ steps.push_screenshots.outputs.branch }}
          SCREENSHOTS_FOLDER: ${{ steps.push_screenshots.outputs.folder }}
          R2_BASE_URL: https://breathe-together-v2.palladio-registry.workers.dev
        with:
          script: |
            const fs = require('fs');
            const prNumber = parseInt(process.env.PR_NUMBER);
            const previewUrl = process.env.PREVIEW_URL;
            const workflowRunId = process.env.WORKFLOW_RUN_ID;
            const hasScreenshots = process.env.HAS_SCREENSHOTS === 'true';
            const captureOutcome = process.env.CAPTURE_OUTCOME;
            const screenshotsBranch = process.env.SCREENSHOTS_BRANCH || 'screenshots';
            const screenshotsFolder = process.env.SCREENSHOTS_FOLDER || `pr-${prNumber}`;
            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
            const artifactUrl = `${repoUrl}/actions/runs/${workflowRunId}`;
            const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19) + ' UTC';

            // Base URLs for image access (prefer R2, fallback to GitHub raw)
            const r2BaseUrl = process.env.R2_BASE_URL;
            const rawBaseUrl = `https://raw.githubusercontent.com/${context.repo.owner}/${context.repo.repo}/${screenshotsBranch}/${screenshotsFolder}`;

            // Use R2 URL pattern: /api/screenshots/pr-{number}/{viewport}/{state}/{id}
            // For embedded images, we'll use the R2 API listing endpoint
            const getR2ImageUrl = (viewport, state) =>
              `${r2BaseUrl}/api/screenshots/pr-${prNumber}/${viewport}/${state}`;

            // List captured screenshots from the PR folder on screenshots branch
            const screenshotsDir = `./${screenshotsFolder}`;
            let screenshotFiles = [];
            try {
              screenshotFiles = fs.readdirSync(screenshotsDir).filter(f => f.endsWith('.png'));
              console.log(`Found ${screenshotFiles.length} screenshots in ${screenshotsDir}`);
            } catch (e) {
              console.log('No screenshots directory found, trying fallback...');
              // Fallback: try the original screenshots directory
              try {
                screenshotFiles = fs.readdirSync('./screenshots').filter(f => f.endsWith('.png'));
              } catch (e2) {
                console.log('No screenshots found in either location');
              }
            }

            // Build status indicator
            let statusEmoji, statusText;
            if (hasScreenshots && captureOutcome === 'success') {
              statusEmoji = '‚úÖ';
              statusText = 'Screenshots captured successfully';
            } else if (hasScreenshots) {
              statusEmoji = '‚ö†Ô∏è';
              statusText = 'Partial capture (some viewports may have failed)';
            } else {
              statusEmoji = '‚ùå';
              statusText = 'Screenshot capture failed - check workflow logs';
            }

            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.data.find(comment =>
              comment.body.includes('<!-- preview-screenshots-comment -->')
            );

            const bodyParts = [
              '<!-- preview-screenshots-comment -->',
              '## üì∏ Preview Screenshots',
              '',
              `${statusEmoji} ${statusText}`,
              '',
              `Screenshots captured from [preview deployment](${previewUrl})`,
              '',
            ];

            if (hasScreenshots) {
              // Helper to get R2 URL for a screenshot
              // Format: /api/screenshots/pr-{prNumber}/{viewport}-{state}.png
              const getImageUrl = (viewport, state) =>
                `${r2BaseUrl}/api/screenshots/pr-${prNumber}/${viewport}-${state}.png`;

              // Group screenshots by device
              const devices = [
                { name: 'Desktop', prefix: 'desktop', emoji: 'üñ•Ô∏è', resolution: '1920√ó1080' },
                { name: 'Tablet', prefix: 'tablet', emoji: 'üì±', resolution: '768√ó1024' },
                { name: 'Mobile', prefix: 'mobile', emoji: 'üì±', resolution: '375√ó667' },
              ];

              for (const device of devices) {
                const deviceFiles = screenshotFiles.filter(f => f.startsWith(device.prefix));
                if (deviceFiles.length > 0) {
                  bodyParts.push(
                    `### ${device.emoji} ${device.name} (${device.resolution})`,
                    '',
                  );

                  // Add images in a table for side-by-side comparison
                  const initialFile = deviceFiles.find(f => f.includes('initial'));
                  const animationFile = deviceFiles.find(f => f.includes('animation'));
                  const errorFile = deviceFiles.find(f => f.includes('error'));

                  // Use R2 URLs for images (CDN-delivered, permanent storage)
                  if (initialFile && animationFile) {
                    bodyParts.push(
                      '| Initial State | Animation State |',
                      '|:-------------:|:---------------:|',
                      `| ![Initial](${getImageUrl(device.prefix, 'initial')}) | ![Animation](${getImageUrl(device.prefix, 'animation')}) |`,
                      '',
                    );
                  } else if (initialFile) {
                    bodyParts.push(
                      `![${device.name} Initial](${getImageUrl(device.prefix, 'initial')})`,
                      '',
                    );
                  } else if (errorFile) {
                    bodyParts.push(
                      `![${device.name} Error State](${getImageUrl(device.prefix, 'error')})`,
                      '',
                      '> ‚ö†Ô∏è Error occurred during capture - showing fallback screenshot',
                      '',
                    );
                  }
                }
              }

              bodyParts.push(
                '<details>',
                '<summary>üì• Download Options</summary>',
                '',
                `- [Download as Artifact](${artifactUrl}) (zip with all screenshots)`,
                `- [Browse R2 Screenshots](${r2BaseUrl}/api/screenshots?pr=${prNumber})`,
                `- [Browse on GitHub](${repoUrl}/tree/${screenshotsBranch}/${screenshotsFolder})`,
                '',
                '</details>',
              );
            }

            bodyParts.push(
              '',
              '---',
              `<sub>Last run: ${timestamp} ‚Ä¢ [View Workflow Run](${artifactUrl})</sub>`,
            );

            const body = bodyParts.join('\n');

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body,
              });
              console.log('Updated existing screenshot comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body,
              });
              console.log('Created new screenshot comment');
            }
