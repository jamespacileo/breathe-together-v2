name: Preview Screenshots

on:
  workflow_run:
    workflows: ["Preview Deployment"]
    types:
      - completed

jobs:
  screenshots:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'pull_request' }}
    name: Capture Screenshots
    permissions:
      contents: write
      pull-requests: write
      actions: read

    steps:
      - uses: actions/checkout@v4

      - name: Get PR number from workflow run
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            // Try to get PR number from workflow_run payload
            const prNumber = context.payload.workflow_run.pull_requests[0]?.number;

            if (prNumber) {
              core.setOutput('number', prNumber);
              core.setOutput('found', 'true');
              console.log(`Found PR #${prNumber} from workflow_run payload`);
              return;
            }

            // Fallback: search for PR by head SHA (works for fork PRs too)
            const headSha = context.payload.workflow_run.head_sha;
            console.log(`Searching for PR with head SHA: ${headSha}`);

            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            const matchingPr = prs.find(pr => pr.head.sha === headSha);

            if (matchingPr) {
              core.setOutput('number', matchingPr.number);
              core.setOutput('found', 'true');
              console.log(`Found PR #${matchingPr.number} by SHA match`);
              return;
            }

            // Final fallback: search by branch name (same-repo PRs only)
            const headBranch = context.payload.workflow_run.head_branch;
            console.log(`Searching for PR with head branch: ${headBranch}`);

            const branchPr = prs.find(pr =>
              pr.head.ref === headBranch &&
              pr.head.repo?.full_name === `${context.repo.owner}/${context.repo.repo}`
            );

            if (branchPr) {
              core.setOutput('number', branchPr.number);
              core.setOutput('found', 'true');
              console.log(`Found PR #${branchPr.number} by branch match`);
              return;
            }

            core.setOutput('found', 'false');
            core.setFailed(`Could not find PR for SHA ${headSha} or branch ${headBranch}`);

      - name: Build preview URL
        if: steps.pr.outputs.found == 'true'
        id: preview
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          # Cloudflare Workers subdomain - update if account changes
          WORKERS_SUBDOMAIN: palladio-registry.workers.dev
        run: |
          PREVIEW_URL="https://breathe-together-v2-pr-${PR_NUMBER}.${WORKERS_SUBDOMAIN}"
          echo "url=${PREVIEW_URL}" >> $GITHUB_OUTPUT
          echo "Preview URL: ${PREVIEW_URL}"

      - name: Wait for preview to be ready
        if: steps.pr.outputs.found == 'true'
        run: |
          echo "Waiting for preview deployment to be accessible..."
          PREVIEW_URL="${{ steps.preview.outputs.url }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PREVIEW_URL" || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Preview is ready (HTTP $HTTP_STATUS)"
              exit 0
            fi
            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS: HTTP $HTTP_STATUS, waiting..."
            sleep 5
            ATTEMPT=$((ATTEMPT + 1))
          done

          echo "::warning::Preview may not be fully ready after ${MAX_ATTEMPTS} attempts, proceeding anyway..."

      - name: Setup Node.js
        if: steps.pr.outputs.found == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        if: steps.pr.outputs.found == 'true'
        run: |
          npm init -y
          npm install playwright@latest
          npx playwright install chromium --with-deps

      - name: Create screenshot script
        if: steps.pr.outputs.found == 'true'
        run: |
          cat > screenshot.mjs << 'EOF'
          import { chromium } from 'playwright';
          import { mkdir } from 'fs/promises';
          import { existsSync } from 'fs';

          const PREVIEW_URL = process.env.PREVIEW_URL;
          const SCREENSHOTS_DIR = './screenshots';

          // =============================================================================
          // Breathing Cycle Configuration (must match src/constants.ts)
          // =============================================================================
          const BREATH_PHASES = {
            INHALE: 4,      // 0-4s
            HOLD_IN: 7,     // 4-11s
            EXHALE: 8,      // 11-19s
            HOLD_OUT: 0,    // skipped
          };
          const TOTAL_CYCLE = BREATH_PHASES.INHALE + BREATH_PHASES.HOLD_IN +
                              BREATH_PHASES.EXHALE + BREATH_PHASES.HOLD_OUT; // 19s

          // Phase timing boundaries (seconds into cycle)
          const PHASE_BOUNDARIES = {
            inhale: { start: 0, end: BREATH_PHASES.INHALE },
            holdIn: { start: BREATH_PHASES.INHALE, end: BREATH_PHASES.INHALE + BREATH_PHASES.HOLD_IN },
            exhale: { start: BREATH_PHASES.INHALE + BREATH_PHASES.HOLD_IN, end: TOTAL_CYCLE },
          };

          // =============================================================================
          // Screens to Capture
          // =============================================================================
          const SCREENS = [
            // Breathing phases - capture at mid-point of each phase for best visual
            {
              name: 'inhale',
              path: '/',
              waitForPhase: 'inhale',
              description: 'Breathing app - Inhale phase (particles contracting)'
            },
            {
              name: 'hold',
              path: '/',
              waitForPhase: 'holdIn',
              description: 'Breathing app - Hold phase (particles at rest, close)'
            },
            {
              name: 'exhale',
              path: '/',
              waitForPhase: 'exhale',
              description: 'Breathing app - Exhale phase (particles expanding)'
            },
            // Admin panel - no phase needed
            {
              name: 'admin',
              path: '/admin',
              waitForPhase: null,
              description: 'Admin panel'
            },
          ];

          // Viewport configurations
          const VIEWPORTS = [
            { name: 'desktop', width: 1920, height: 1080 },
            { name: 'tablet', width: 768, height: 1024 },
            { name: 'mobile', width: 375, height: 667 },
          ];

          // =============================================================================
          // Phase Timing Utilities
          // =============================================================================

          /**
           * Get current position in breathing cycle (0 to TOTAL_CYCLE seconds)
           */
          function getCyclePosition() {
            const nowSeconds = Date.now() / 1000;
            return nowSeconds % TOTAL_CYCLE;
          }

          /**
           * Calculate milliseconds until mid-point of target phase
           */
          function getMsUntilPhaseMidpoint(targetPhase) {
            const boundaries = PHASE_BOUNDARIES[targetPhase];
            if (!boundaries) return 0;

            const phaseMidpoint = (boundaries.start + boundaries.end) / 2;
            const currentPos = getCyclePosition();

            let secondsUntil = phaseMidpoint - currentPos;
            if (secondsUntil < 0) {
              // Phase already passed in this cycle, wait for next cycle
              secondsUntil += TOTAL_CYCLE;
            }

            // If we're very close (within 0.5s), just capture now
            if (secondsUntil < 0.5) {
              return 0;
            }

            return Math.ceil(secondsUntil * 1000);
          }

          /**
           * Get current phase name for logging
           */
          function getCurrentPhaseName() {
            const pos = getCyclePosition();
            if (pos < PHASE_BOUNDARIES.inhale.end) return 'inhale';
            if (pos < PHASE_BOUNDARIES.holdIn.end) return 'holdIn';
            return 'exhale';
          }

          // =============================================================================
          // Screenshot Capture
          // =============================================================================

          async function waitForPageReady(page, isCanvas = true) {
            if (isCanvas) {
              // Wait for WebGL canvas
              await page.waitForSelector('canvas', { timeout: 30000 });
              // Wait for Three.js to initialize and render first frame
              await page.waitForTimeout(3000);
            } else {
              // Wait for page to be interactive
              await page.waitForLoadState('networkidle');
              await page.waitForTimeout(1000);
            }
          }

          async function captureScreenshots() {
            if (!existsSync(SCREENSHOTS_DIR)) {
              await mkdir(SCREENSHOTS_DIR, { recursive: true });
            }

            let browser;
            try {
              browser = await chromium.launch({
                args: ['--use-gl=angle', '--use-angle=swiftshader'],
              });

              console.log(`Capturing screenshots from: ${PREVIEW_URL}`);
              console.log(`Breathing cycle: ${TOTAL_CYCLE}s (Inhale: ${BREATH_PHASES.INHALE}s, Hold: ${BREATH_PHASES.HOLD_IN}s, Exhale: ${BREATH_PHASES.EXHALE}s)\n`);

              for (const viewport of VIEWPORTS) {
                console.log(`\n${'='.repeat(60)}`);
                console.log(`ðŸ“± ${viewport.name.toUpperCase()} (${viewport.width}Ã—${viewport.height})`);
                console.log('='.repeat(60));

                const context = await browser.newContext({
                  viewport: { width: viewport.width, height: viewport.height },
                  deviceScaleFactor: 1,
                });

                for (const screen of SCREENS) {
                  const page = await context.newPage();
                  const filename = `${viewport.name}-${screen.name}.png`;
                  const isCanvasPage = screen.path === '/';

                  try {
                    console.log(`\nðŸ“¸ ${screen.description}`);

                    // Navigate to the screen
                    const url = `${PREVIEW_URL}${screen.path}`;
                    console.log(`   Loading: ${url}`);

                    await page.goto(url, {
                      waitUntil: 'networkidle',
                      timeout: 60000,
                    });

                    // Wait for page to be ready
                    await waitForPageReady(page, isCanvasPage);

                    // If this screen needs a specific breathing phase, wait for it
                    if (screen.waitForPhase) {
                      const msUntil = getMsUntilPhaseMidpoint(screen.waitForPhase);
                      if (msUntil > 0) {
                        console.log(`   Current phase: ${getCurrentPhaseName()}`);
                        console.log(`   Waiting ${(msUntil/1000).toFixed(1)}s for ${screen.waitForPhase} phase...`);
                        await page.waitForTimeout(msUntil);
                      }
                      console.log(`   Now at: ${getCurrentPhaseName()} phase âœ“`);
                    }

                    // Capture screenshot
                    await page.screenshot({
                      path: `${SCREENSHOTS_DIR}/${filename}`,
                      fullPage: false,
                    });
                    console.log(`   âœ… Saved: ${filename}`);

                  } catch (error) {
                    console.error(`   âŒ Error: ${error.message}`);

                    // Try to capture error state
                    try {
                      const errorFilename = `${viewport.name}-${screen.name}-error.png`;
                      await page.screenshot({
                        path: `${SCREENSHOTS_DIR}/${errorFilename}`,
                        fullPage: false,
                      });
                      console.log(`   âš ï¸ Saved fallback: ${errorFilename}`);
                    } catch (e) {
                      console.error(`   âŒ Could not capture fallback`);
                    }
                  } finally {
                    await page.close();
                  }
                }

                await context.close();
              }

              console.log(`\n${'='.repeat(60)}`);
              console.log('âœ¨ Screenshot capture complete!');
              console.log('='.repeat(60));

            } finally {
              if (browser) {
                await browser.close();
              }
            }
          }

          captureScreenshots().catch((error) => {
            console.error('Fatal error:', error);
            process.exit(1);
          });
          EOF

      - name: Capture screenshots
        id: capture
        if: steps.pr.outputs.found == 'true'
        continue-on-error: true
        env:
          PREVIEW_URL: ${{ steps.preview.outputs.url }}
        run: |
          node screenshot.mjs
          # Check if we got any screenshots
          if [ -d "./screenshots" ] && [ "$(ls -A ./screenshots 2>/dev/null)" ]; then
            echo "has_screenshots=true" >> $GITHUB_OUTPUT
            echo "Screenshots captured:"
            ls -la ./screenshots/
          else
            echo "has_screenshots=false" >> $GITHUB_OUTPUT
            echo "::warning::No screenshots were captured"
          fi

      - name: Upload screenshots as artifact
        if: steps.pr.outputs.found == 'true' && steps.capture.outputs.has_screenshots == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: preview-screenshots-pr-${{ steps.pr.outputs.number }}
          path: screenshots/
          retention-days: 30
          if-no-files-found: warn

      - name: Push screenshots to branch for inline display
        if: steps.pr.outputs.found == 'true' && steps.capture.outputs.has_screenshots == 'true'
        id: push_screenshots
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Save screenshots to temp location before branch switch
          TEMP_SCREENSHOTS="/tmp/screenshots-pr-${PR_NUMBER}"
          mkdir -p "${TEMP_SCREENSHOTS}"
          cp ./screenshots/*.png "${TEMP_SCREENSHOTS}/"
          echo "Saved screenshots to temp location:"
          ls -la "${TEMP_SCREENSHOTS}/"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create or checkout the screenshots branch
          SCREENSHOTS_BRANCH="screenshots"
          PR_FOLDER="pr-${PR_NUMBER}"

          # Fetch the branch if it exists, or create it as orphan
          if git ls-remote --heads origin ${SCREENSHOTS_BRANCH} | grep -q ${SCREENSHOTS_BRANCH}; then
            git fetch origin ${SCREENSHOTS_BRANCH}
            git checkout ${SCREENSHOTS_BRANCH}
          else
            git checkout --orphan ${SCREENSHOTS_BRANCH}
            git rm -rf . 2>/dev/null || true
            echo "# Preview Screenshots" > README.md
            echo "" >> README.md
            echo "This branch contains automatically generated screenshots from PR previews." >> README.md
            git add README.md
            git commit -m "Initialize screenshots branch"
          fi

          # Clean up old screenshots for this PR and add new ones from temp location
          rm -rf "${PR_FOLDER}"
          mkdir -p "${PR_FOLDER}"
          cp "${TEMP_SCREENSHOTS}"/*.png "${PR_FOLDER}/"
          echo "Copied screenshots to PR folder:"
          ls -la "${PR_FOLDER}/"

          # Commit and push
          git add "${PR_FOLDER}"
          git commit -m "Update screenshots for PR #${PR_NUMBER}" || echo "No changes to commit"
          git push origin ${SCREENSHOTS_BRANCH}

          # Cleanup temp
          rm -rf "${TEMP_SCREENSHOTS}"

          # Output the raw URL base
          echo "branch=${SCREENSHOTS_BRANCH}" >> $GITHUB_OUTPUT
          echo "folder=${PR_FOLDER}" >> $GITHUB_OUTPUT

      - name: Comment PR with screenshots
        if: steps.pr.outputs.found == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          PREVIEW_URL: ${{ steps.preview.outputs.url }}
          WORKFLOW_RUN_ID: ${{ github.run_id }}
          HAS_SCREENSHOTS: ${{ steps.capture.outputs.has_screenshots }}
          CAPTURE_OUTCOME: ${{ steps.capture.outcome }}
          SCREENSHOTS_BRANCH: ${{ steps.push_screenshots.outputs.branch }}
          SCREENSHOTS_FOLDER: ${{ steps.push_screenshots.outputs.folder }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = parseInt(process.env.PR_NUMBER);
            const previewUrl = process.env.PREVIEW_URL;
            const workflowRunId = process.env.WORKFLOW_RUN_ID;
            const hasScreenshots = process.env.HAS_SCREENSHOTS === 'true';
            const captureOutcome = process.env.CAPTURE_OUTCOME;
            const screenshotsBranch = process.env.SCREENSHOTS_BRANCH || 'screenshots';
            const screenshotsFolder = process.env.SCREENSHOTS_FOLDER || `pr-${prNumber}`;
            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
            const artifactUrl = `${repoUrl}/actions/runs/${workflowRunId}`;
            const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19) + ' UTC';

            // Base URL for raw image access
            const rawBaseUrl = `https://raw.githubusercontent.com/${context.repo.owner}/${context.repo.repo}/${screenshotsBranch}/${screenshotsFolder}`;

            // List captured screenshots from the PR folder on screenshots branch
            const screenshotsDir = `./${screenshotsFolder}`;
            let screenshotFiles = [];
            try {
              screenshotFiles = fs.readdirSync(screenshotsDir).filter(f => f.endsWith('.png'));
              console.log(`Found ${screenshotFiles.length} screenshots in ${screenshotsDir}`);
            } catch (e) {
              console.log('No screenshots directory found, trying fallback...');
              // Fallback: try the original screenshots directory
              try {
                screenshotFiles = fs.readdirSync('./screenshots').filter(f => f.endsWith('.png'));
              } catch (e2) {
                console.log('No screenshots found in either location');
              }
            }

            // Build status indicator
            let statusEmoji, statusText;
            if (hasScreenshots && captureOutcome === 'success') {
              statusEmoji = 'âœ…';
              statusText = 'Screenshots captured successfully';
            } else if (hasScreenshots) {
              statusEmoji = 'âš ï¸';
              statusText = 'Partial capture (some viewports may have failed)';
            } else {
              statusEmoji = 'âŒ';
              statusText = 'Screenshot capture failed - check workflow logs';
            }

            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.data.find(comment =>
              comment.body.includes('<!-- preview-screenshots-comment -->')
            );

            const bodyParts = [
              '<!-- preview-screenshots-comment -->',
              '## ðŸ“¸ Preview Screenshots',
              '',
              `${statusEmoji} ${statusText}`,
              '',
              `Screenshots captured from [preview deployment](${previewUrl})`,
              '',
            ];

            if (hasScreenshots) {
              // Screen types we capture
              const screens = [
                { name: 'inhale', label: 'Inhale', description: 'Particles contracting' },
                { name: 'hold', label: 'Hold', description: 'Particles at rest' },
                { name: 'exhale', label: 'Exhale', description: 'Particles expanding' },
                { name: 'admin', label: 'Admin', description: 'Admin panel' },
              ];

              // Device configurations
              const devices = [
                { name: 'Desktop', prefix: 'desktop', emoji: 'ðŸ–¥ï¸', resolution: '1920Ã—1080' },
                { name: 'Tablet', prefix: 'tablet', emoji: 'ðŸ“±', resolution: '768Ã—1024' },
                { name: 'Mobile', prefix: 'mobile', emoji: 'ðŸ“±', resolution: '375Ã—667' },
              ];

              // Breathing phases section
              bodyParts.push('### ðŸ« Breathing Phases', '');

              for (const device of devices) {
                const breathingFiles = screens
                  .filter(s => s.name !== 'admin')
                  .map(s => `${device.prefix}-${s.name}.png`)
                  .filter(f => screenshotFiles.includes(f));

                if (breathingFiles.length > 0) {
                  bodyParts.push(`**${device.emoji} ${device.name}** (${device.resolution})`, '');

                  // Create table header
                  const availableScreens = screens.filter(s =>
                    s.name !== 'admin' && screenshotFiles.includes(`${device.prefix}-${s.name}.png`)
                  );

                  if (availableScreens.length > 0) {
                    const headers = availableScreens.map(s => s.label);
                    const dividers = availableScreens.map(() => ':---:');
                    const images = availableScreens.map(s =>
                      `![${s.label}](${rawBaseUrl}/${device.prefix}-${s.name}.png)`
                    );

                    bodyParts.push(
                      `| ${headers.join(' | ')} |`,
                      `| ${dividers.join(' | ')} |`,
                      `| ${images.join(' | ')} |`,
                      '',
                    );
                  }
                }
              }

              // Admin panel section
              const adminFiles = devices
                .map(d => ({ device: d, file: `${d.prefix}-admin.png` }))
                .filter(({ file }) => screenshotFiles.includes(file));

              if (adminFiles.length > 0) {
                bodyParts.push(
                  '<details>',
                  '<summary>ðŸ”§ Admin Panel Screenshots</summary>',
                  '',
                );

                for (const { device, file } of adminFiles) {
                  bodyParts.push(
                    `**${device.emoji} ${device.name}**`,
                    '',
                    `![Admin - ${device.name}](${rawBaseUrl}/${file})`,
                    '',
                  );
                }

                bodyParts.push('</details>', '');
              }

              // Download options
              bodyParts.push(
                '<details>',
                '<summary>ðŸ“¥ Download Options</summary>',
                '',
                `- [Download as Artifact](${artifactUrl}) (zip with all screenshots)`,
                `- [Browse on GitHub](${repoUrl}/tree/${screenshotsBranch}/${screenshotsFolder})`,
                '',
                '</details>',
              );
            }

            bodyParts.push(
              '',
              '---',
              `<sub>Last run: ${timestamp} â€¢ [View Workflow Run](${artifactUrl})</sub>`,
            );

            const body = bodyParts.join('\n');

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body,
              });
              console.log('Updated existing screenshot comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body,
              });
              console.log('Created new screenshot comment');
            }
