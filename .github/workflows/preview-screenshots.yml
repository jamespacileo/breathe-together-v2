name: Preview Screenshots

# SECURITY NOTE: This workflow uses workflow_run trigger to run in the base
# repository context (not the PR context). This prevents exposing secrets to
# fork PRs while still allowing screenshot capture.
#
# IMPORTANT: workflow_run trigger only works when this file exists on the
# default branch (main). Changes to this workflow in feature branches won't
# take effect until merged. Use workflow_dispatch for testing.
#
# TRIGGER BEHAVIOR: This workflow fires on workflow completion (not just success)
# and then checks if the "Deploy Preview" job specifically succeeded. This allows
# screenshots to be captured even if the "Code Validation" job fails (common
# during active development).
#
# If the "Preview Deployment" workflow name changes, update line 14 below.

on:
  workflow_run:
    workflows: ["Preview Deployment"]
    types:
      - completed

  # Manual trigger for testing changes before they're merged to main
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to capture screenshots for'
        required: true
        type: number

jobs:
  screenshots:
    runs-on: ubuntu-latest
    # Run on workflow_run completion (not just success) OR manual trigger
    # We check if deploy-preview job succeeded, not the entire workflow
    # This allows screenshots even if validate job failed (common during development)
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.event == 'pull_request' }}
    name: Capture Screenshots
    permissions:
      contents: write
      pull-requests: write
      actions: read

    # Environment variables shared across all steps
    env:
      # NOTE: Update this if Cloudflare account changes
      # Alternative: Store as repository variable CLOUDFLARE_WORKERS_SUBDOMAIN
      CLOUDFLARE_WORKERS_SUBDOMAIN: palladio-registry.workers.dev

    steps:
      - uses: actions/checkout@v4

      - name: Check deploy-preview job succeeded
        id: check_deployment
        if: github.event_name != 'workflow_dispatch'
        uses: actions/github-script@v7
        with:
          script: |
            // Get the jobs from the triggering workflow run
            const runId = context.payload.workflow_run.id;
            console.log(`Checking jobs for workflow run #${runId}`);

            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
            });

            // Find the deploy-preview job
            const deployJob = jobs.jobs.find(job => job.name === 'Deploy Preview');

            if (!deployJob) {
              console.log('Available jobs:', jobs.jobs.map(j => j.name).join(', '));
              core.setFailed('Could not find Deploy Preview job');
              return;
            }

            console.log(`Deploy Preview job status: ${deployJob.conclusion}`);

            if (deployJob.conclusion !== 'success') {
              core.setFailed(`Deploy Preview job did not succeed (conclusion: ${deployJob.conclusion})`);
              return;
            }

            core.setOutput('success', 'true');
            console.log('Deploy Preview job succeeded - proceeding with screenshots');

      - name: Get PR number from workflow run
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            // Strategy 0: Manual trigger (workflow_dispatch with PR number input)
            if (context.eventName === 'workflow_dispatch') {
              const prNumber = context.payload.inputs.pr_number;
              core.setOutput('number', prNumber);
              core.setOutput('found', 'true');
              console.log(`Manual trigger for PR #${prNumber}`);
              return;
            }

            // Strategy 1: Try to get PR number from workflow_run payload (most reliable)
            const prNumber = context.payload.workflow_run?.pull_requests[0]?.number;

            if (prNumber) {
              core.setOutput('number', prNumber);
              core.setOutput('found', 'true');
              console.log(`Found PR #${prNumber} from workflow_run payload`);
              return;
            }

            // Strategy 2: Search for PR by head SHA (works for fork PRs)
            const headSha = context.payload.workflow_run?.head_sha;
            if (!headSha) {
              core.setOutput('found', 'false');
              core.setFailed('Could not determine PR number');
              return;
            }
            console.log(`Searching for PR with head SHA: ${headSha}`);

            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            const matchingPr = prs.find(pr => pr.head.sha === headSha);

            if (matchingPr) {
              core.setOutput('number', matchingPr.number);
              core.setOutput('found', 'true');
              console.log(`Found PR #${matchingPr.number} by SHA match`);
              return;
            }

            // Strategy 3: Search by branch name (same-repo PRs only)
            const headBranch = context.payload.workflow_run?.head_branch;
            console.log(`Searching for PR with head branch: ${headBranch}`);

            const branchPr = prs.find(pr =>
              pr.head.ref === headBranch &&
              pr.head.repo?.full_name === `${context.repo.owner}/${context.repo.repo}`
            );

            if (branchPr) {
              core.setOutput('number', branchPr.number);
              core.setOutput('found', 'true');
              console.log(`Found PR #${branchPr.number} by branch match`);
              return;
            }

            core.setOutput('found', 'false');
            core.setFailed(`Could not find PR for SHA ${headSha} or branch ${headBranch}`);

      - name: Build preview URL
        if: steps.pr.outputs.found == 'true'
        id: preview
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        run: |
          PREVIEW_URL="https://breathe-together-v2-pr-${PR_NUMBER}.${CLOUDFLARE_WORKERS_SUBDOMAIN}"
          echo "url=${PREVIEW_URL}" >> $GITHUB_OUTPUT
          echo "Preview URL: ${PREVIEW_URL}"

      - name: Setup Node.js
        if: steps.pr.outputs.found == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache Playwright browsers
        if: steps.pr.outputs.found == 'true'
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-chromium-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            playwright-${{ runner.os }}-chromium-

      - name: Install Playwright
        if: steps.pr.outputs.found == 'true'
        run: |
          # Skip npm init - not needed
          npm install playwright@latest

          # Only download browsers if cache miss
          if [ "${{ steps.playwright-cache.outputs.cache-hit }}" != "true" ]; then
            echo "Cache miss - downloading Chromium (~170MB)..."
            npx playwright install chromium --with-deps
          else
            echo "Cache hit - skipping browser download"
            # Still need system dependencies
            npx playwright install-deps chromium
          fi

      - name: Wait for preview to be ready
        if: steps.pr.outputs.found == 'true'
        env:
          PREVIEW_URL: ${{ steps.preview.outputs.url }}
        run: |
          # Use improved readiness check (verifies canvas exists and renders)
          node .github/scripts/wait-for-preview.mjs

      - name: Capture screenshots
        id: capture
        if: steps.pr.outputs.found == 'true'
        env:
          PREVIEW_URL: ${{ steps.preview.outputs.url }}
        run: |
          # Use extracted screenshot script
          node .github/scripts/screenshot.mjs

          # Verify screenshots were created
          if [ -d "./screenshots" ] && [ "$(ls -A ./screenshots/*.png 2>/dev/null | wc -l)" -gt 0 ]; then
            echo "has_screenshots=true" >> $GITHUB_OUTPUT
            echo "Screenshots captured:"
            ls -lah ./screenshots/
          else
            echo "has_screenshots=false" >> $GITHUB_OUTPUT
            echo "âŒ No screenshots were captured"
            exit 1
          fi

      - name: Upload screenshots as artifact
        if: steps.pr.outputs.found == 'true' && steps.capture.outputs.has_screenshots == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: preview-screenshots-pr-${{ steps.pr.outputs.number }}
          path: screenshots/
          retention-days: 30
          if-no-files-found: warn

      - name: Push screenshots to branch for inline display
        if: steps.pr.outputs.found == 'true' && steps.capture.outputs.has_screenshots == 'true'
        id: push_screenshots
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        run: |
          # Make script executable
          chmod +x .github/scripts/push-screenshots.sh

          # Run git push script with error handling and retry logic
          .github/scripts/push-screenshots.sh

      - name: Comment PR with screenshots
        if: steps.pr.outputs.found == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          PREVIEW_URL: ${{ steps.preview.outputs.url }}
          WORKFLOW_RUN_ID: ${{ github.run_id }}
          HAS_SCREENSHOTS: ${{ steps.capture.outputs.has_screenshots }}
          CAPTURE_OUTCOME: ${{ steps.capture.outcome }}
          SCREENSHOTS_BRANCH: ${{ steps.push_screenshots.outputs.branch }}
          SCREENSHOTS_FOLDER: ${{ steps.push_screenshots.outputs.folder }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = parseInt(process.env.PR_NUMBER);
            const previewUrl = process.env.PREVIEW_URL;
            const workflowRunId = process.env.WORKFLOW_RUN_ID;
            const hasScreenshots = process.env.HAS_SCREENSHOTS === 'true';
            const captureOutcome = process.env.CAPTURE_OUTCOME;
            const screenshotsBranch = process.env.SCREENSHOTS_BRANCH || 'screenshots';
            const screenshotsFolder = process.env.SCREENSHOTS_FOLDER || `pr-${prNumber}`;
            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
            const artifactUrl = `${repoUrl}/actions/runs/${workflowRunId}`;
            const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19) + ' UTC';

            // Base URL for raw image access
            const rawBaseUrl = `https://raw.githubusercontent.com/${context.repo.owner}/${context.repo.repo}/${screenshotsBranch}/${screenshotsFolder}`;

            // List captured screenshots from working directory
            let screenshotFiles = [];
            try {
              // Try screenshots directory first (where script saves them)
              if (fs.existsSync('./screenshots')) {
                screenshotFiles = fs.readdirSync('./screenshots').filter(f => f.endsWith('.png'));
                console.log(`Found ${screenshotFiles.length} screenshots in ./screenshots/`);
              }
            } catch (e) {
              console.error('Error reading screenshots:', e.message);
            }

            // Build status indicator
            let statusEmoji, statusText;
            if (hasScreenshots && captureOutcome === 'success') {
              statusEmoji = 'âœ…';
              statusText = 'Screenshots captured successfully';
            } else if (hasScreenshots) {
              statusEmoji = 'âš ï¸';
              statusText = 'Partial capture (some viewports may have failed)';
            } else {
              statusEmoji = 'âŒ';
              statusText = 'Screenshot capture failed - check workflow logs';
            }

            // Find existing comment (with pagination support)
            let botComment = null;
            for await (const response of github.paginate.iterator(
              github.rest.issues.listComments,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                per_page: 100,
              }
            )) {
              botComment = response.data.find(comment =>
                comment.body.includes('<!-- preview-screenshots-comment -->')
              );
              if (botComment) break;
            }

            const bodyParts = [
              '<!-- preview-screenshots-comment -->',
              '## ðŸ“¸ Preview Screenshots',
              '',
              `${statusEmoji} ${statusText}`,
              '',
              `Screenshots captured from [preview deployment](${previewUrl})`,
              '',
            ];

            if (hasScreenshots) {
              // Breathing screens configuration
              const breathingScreens = [
                { name: 'inhale', label: 'Inhale', description: 'Particles contracting' },
                { name: 'hold', label: 'Hold', description: 'Particles at rest' },
                { name: 'exhale', label: 'Exhale', description: 'Particles expanding' },
              ];

              // Static screens configuration
              const staticScreens = [
                { name: 'admin', label: 'Admin', description: 'Admin panel' },
              ];

              // Device configurations with thumbnail widths
              const devices = [
                { name: 'Desktop', prefix: 'desktop', emoji: 'ðŸ–¥ï¸', resolution: '1920Ã—1080', thumbWidth: 280 },
                { name: 'Tablet', prefix: 'tablet', emoji: 'ðŸ“±', resolution: '768Ã—1024', thumbWidth: 200 },
                { name: 'Mobile', prefix: 'mobile', emoji: 'ðŸ“±', resolution: '375Ã—667', thumbWidth: 140 },
              ];

              // Helper: Create clickable thumbnail HTML (small preview, click for full size)
              const makeThumb = (url, alt, width) =>
                `<a href="${url}"><img src="${url}" alt="${alt}" width="${width}" /></a>`;

              // Breathing phases section
              bodyParts.push('### ðŸ« Breathing Phases', '');
              bodyParts.push('*Click any image to view full size*', '');

              for (const device of devices) {
                const availableScreens = breathingScreens.filter(s =>
                  screenshotFiles.includes(`${device.prefix}-${s.name}.png`)
                );

                if (availableScreens.length > 0) {
                  bodyParts.push(`**${device.emoji} ${device.name}** (${device.resolution})`, '');

                  // Create HTML table for better control over image sizes
                  const headers = availableScreens.map(s => s.label);
                  const thumbs = availableScreens.map(s => {
                    const url = `${rawBaseUrl}/${device.prefix}-${s.name}.png`;
                    return makeThumb(url, `${device.name} - ${s.label}`, device.thumbWidth);
                  });

                  bodyParts.push(
                    '<table>',
                    `<tr>${headers.map(h => `<th align="center">${h}</th>`).join('')}</tr>`,
                    `<tr>${thumbs.map(t => `<td align="center">${t}</td>`).join('')}</tr>`,
                    '</table>',
                    '',
                  );
                }
              }

              // Static screens section (admin panel)
              const adminFiles = devices
                .map(d => ({ device: d, file: `${d.prefix}-admin.png` }))
                .filter(({ file }) => screenshotFiles.includes(file));

              if (adminFiles.length > 0) {
                bodyParts.push(
                  '<details>',
                  '<summary>ðŸ”§ Admin Panel Screenshots</summary>',
                  '',
                  '*Click any image to view full size*',
                  '',
                );

                // Create horizontal layout for admin screenshots
                bodyParts.push('<table><tr>');
                for (const { device, file } of adminFiles) {
                  const url = `${rawBaseUrl}/${file}`;
                  bodyParts.push(
                    `<td align="center">`,
                    `<strong>${device.emoji} ${device.name}</strong><br/>`,
                    makeThumb(url, `Admin - ${device.name}`, device.thumbWidth),
                    `</td>`,
                  );
                }
                bodyParts.push('</tr></table>', '');

                bodyParts.push('</details>', '');
              }

              // Download options
              bodyParts.push(
                '<details>',
                '<summary>ðŸ“¥ Download Options</summary>',
                '',
                `- [Download as Artifact](${artifactUrl}) (zip with all screenshots)`,
                `- [Browse on GitHub](${repoUrl}/tree/${screenshotsBranch}/${screenshotsFolder})`,
                '',
                '</details>',
              );
            }

            bodyParts.push(
              '',
              '---',
              `<sub>Last run: ${timestamp} â€¢ [View Workflow Run](${artifactUrl})</sub>`,
            );

            const body = bodyParts.join('\n');

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body,
              });
              console.log('Updated existing screenshot comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body,
              });
              console.log('Created new screenshot comment');
            }
